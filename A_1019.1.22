1.22---js八种继承方法
  1.原型链继承，每个构造函数都有个原型对象，原型对象有个指向构造函数的指针，实例也有个指向原型对象的指针
    继承就是复制，重写原型对象
    SubType.prototype = new SuperType();
    原型链方案存在的缺点：多个实例对引用类型的操作会被篡改。

  2.原型式继承
    利用一个空对象为中介，直接将某个对象赋值给空对象构造函数的原型
    function object(object){
      function  f(){}
      f.prototype = object
      return new f()
    }
    缺点：无法传递参数，属于浅复制，原型链继承多个实例的引用类型属性指向相同，存在篡改可能
    
  3.ES6-extends类继承
    一个类只能有一个构造函数，默认是constructor
    
 1.23---call,apply，改变this的指向
    区别是call接受的是若干个参数的列表
    apply接受的是多个对象的数组
    var func = function(arg1, arg2) {
         ...
    };
    func.cal(this,arg1,arg2)
    func.apply(this,[arg1,arg2])
    
    1数组合并,Array.prototype.push.apply(arr1,arr2) //将第二个数组添加到第一个，当添加数组过多时会异常或丢失
    2数组最大值最小值，Math.max.apply(Math,numbers),Math.max.call(Math,1,2,3),Math.max.call(Math,...numbers)
    3Array.prototype.slice.call(domNodes),Array.from(),将类数组转换为数组
      类数组：具有对象元素的数字索引下标和length属性，不能进行push，shift，indexOf，forEach等对象方法
      兼容ie，ie9以下dom对象是以com对象实现的，js对象与com对象bb不能呼唤
      function toArray(nodes){
            try {
                // works in every browser except IE
                return Array.prototype.slice.call(nodes);
            } catch(err) {
                // Fails in IE < 9
                var arr = [],
                    length = nodes.length;
                for(var i = 0; i < length; i++){
                    // arr.push(nodes[i]); // 两种都可以
                    arr[i] = nodes[i];
                }
                return arr;
            }
        }
      4.调用父构造函数实现继承
        function  SuperType(){
            this.color=["red", "green", "blue"];
        }
        function  SubType(){
            // 核心代码，继承自SuperType
            SuperType.call(this);
        }
      5.Array.prototype.push.apply(arr1,arr2);    //得到合并后数组的长度，因为push就是返回一个数组的长度
      6.严格模式下use strict，this默认为undefined，普通模式下为window

 1.23---js事件委托和代理
        事件委托就是利用事件冒泡，只指定一个事件处理程序，添加到页面的事件处理程序会影响整体运行性能，与dom节点交互会导致浏览器的重绘和重排
        event对象有一个target对象，可以返回事件的目标节点，成为事件源，标准浏览器为ev.target，ie为event.srcElement，获取当前节点nodeName然后toLowerCase
        window.onload = function(){
		    　　var oUl = document.getElementById("ul1");
		    　　oUl.onclick = function(ev){
		    	　　　　var ev = ev || window.event;
		   		　　　　var target = ev.target || ev.srcElement;
		        　　　　if(target.nodeName.toLowerCase() == 'li'){
		        　 　　　　　　	alert(123);
		　　　　　　　  alert(target.innerHTML);
                }
              }
        }
        

1.23---bind,live，delegate,on 前俩者jq1.7/1.9就不用了
单事件 $("").bind("click",data,function);
多事件$("").bind("click dbclick mouseout",data,function);$("").bind({event1:function, event2:function, ...})
bind绑定当前元素，重复注册
live绑定document跟元素注册一次，但层级太深会影响性能
delegate类型live但是绑定指定元素，注册一次，附加操作前期完成会造成页面加载时性能问题，bind方法不能直接升级到delegate
on使各种事件绑定一致，支持bind方法，
$(...).事件名(function(e){})



	
	
	









	
