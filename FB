重点
1.事件委托

1封装组件
组件封装的目的是为了重用，提高开发效率和代码质量
低耦合，单一职责，可复用性，可维护性
前端组件化设计思路

2js异步加载
渲染引擎遇到 script 标签会停下来，等到执行完脚本，继续向下渲染
defer 是“渲染完再执行”，async 是“下载完就执行”，defer 如果有多个脚本，会按照在页面中出现的顺序加载，多个async 脚本不能保证加载顺序
加载 es6模块的时候设置 type=module，异步加载不会造成阻塞浏览器，页面渲染完再执行，可以同时加上async属性，异步执行脚本（利用顶层的this等于undefined这个语法点，可以侦测当前代码是否在 ES6 模块之中）


3.css动画和js动画
代码复杂度，js 动画代码相对复杂一些
动画运行时，对动画的控制程度上，js 能够让动画，暂停，取消，终止，css动画不能添加事件
动画性能看，js 动画多了一个js 解析的过程，性能不如 css 动画好

4.线程，进程
线程是最小的执行单元，进程是最小的资源管理单元
一个线程只有一个进程
一个进程至少有一个线程

5负载均衡
当系统面临大量用户访问时，负载过高，通过增加服务器这种横向扩展，使用集群和负载均衡提高系统处理努力

6闭包目的
隐藏变量，在函数词法作用域外调用函数
内存泄漏，闭包使用后无法回收

7.网站优化
http 请求方面，减少请求数量，请求体积，对应的做法是，对项目资源进行压缩，控制项目资源的 dns 解析在2到4个域名，提取公告的样式，公共的组件，雪碧图，缓存资源，
压缩资源，提取公共资源压缩，提取 css ，js 公共方法
不要缩放图片，使用雪碧图，使用字体图表（阿里矢量图库）
使用 CDN，抛开无用的 cookie
减少重绘重排，CSS属性读写分离，最好不要用js 修改样式，dom 离线更新，渲染前指定图片的大小
js 代码层面的优化，减少对字符串的计算，合理使用闭包，首屏的js 资源加载放在最底部

8.vue
mvvm模式
vue 通过数据属性的数据劫持和发布订阅的模式实现，大致可以理解成由3个模块组成，observer 完成对数据的劫持，compile 完成对模板片段的渲染，watcher 作为桥梁连接二者，订阅数据变化及更新视图

9.post/get
get请求能缓存，post不能
post采用request body传输get更多的数据
post可以支持更多的编码格式，不对数据类型限制
post更加安全，请求不放在url中显示，get还会保存在浏览器中（抓包结果一样

10.webpack机制
从配置的entry入口文件解析文件开始构建ast语法树，找出每个文件的依赖递归下去
在解析文件的递归过程中根据文件类型和loader配置找出合适的loader对文件进行转换
递归完后对文件根据entry分类生成代码块chunk
输出所有chunk到文件系统

11.
